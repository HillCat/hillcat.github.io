---
layout: post
title: 泛型
categories: .net
description: 英文自学
keywords: English
---
C#中的泛型是.net 2.0的时候引入的。从泛型的语法上看，就是一个尖括号里面一个泛型参数T。泛型解决的问题是：解决不同类型的对象，具有相同的方法调用的时候，封装在一个方法里面，而可以调用不同的方法。我的理解就是相当于是把一类行为相似的东西，给传递给同一个方法里面，让这些行为类似的Object去执行相同的行为，而不需要单独给不同的类型去写一套重复的代码。

### 如果没有泛型，会发生什么

如果没有泛型，需要面对的问题有：

1. 参数类型写死的问题。
2. object类型声明，传入int值，会遇到拆箱和装箱问题。如果方法要求是一个object类型，而你传递了一个int类型，这个时候会遇到装箱的问题，从栈里面到堆里面，数据转换的时候会有性能损失。



### 泛型是如何避免拆箱和装箱的

1. 声明的时候没有指定参数类型，到了调用的时候才指定类型。
2. 使用了延迟声明。

#### 延迟声明，底层是怎么实现的？

问题：C#里面的泛型需要编译器和JIT同时支持。这里比较难的是运行时编译的时候，如何证明JIT把占位符给替换为真实类型了？

回答：无法通过调试的方式实时看到，但是能够通过理论上的推导来证明。

1. 编译器，有占位符把T类型给占位；
2. JIT第二次运行时编译的时候，通过反射会把占位符替换为真实的类型。

通过一个测试，调用三种不同的方法，三种方法的参数类型分别是 int类型，object类型，泛型T；通过for循环1亿次分别调用3个方法，通过秒表计时，会发现明确指定了参数类型的方法和泛型方法，在耗时上面是基本相同的。而object类型的方法执行的时候由于发生了拆箱装箱，性能耗时基本是前者的2倍。这个主要是得益于JIT即时编译，把正确的类型最终转化为二进制本地代码。通过性能耗时上面对比，推测出泛型方法和原生的“强类型被明确声明指定”的这种方法，在耗时上基本一致，推导出泛型内部的机制，最终是把占位符给替换为了和”强类型被明确声明指定“一样的类似的代码，要不然，它们的性能不可能会那么一致。







