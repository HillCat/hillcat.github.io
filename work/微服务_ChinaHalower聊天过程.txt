以下是和ChinaHalower聊天的记录摘要：时间是：2021年11月14日 凌晨1点

CAP分布式事务，牺牲一致性，提升可用性。微服务降低了开发这边复杂度，但是提升了运维复杂度。

强一致性和可用性之间做取舍。微服务过程中会遇到容错，降级这些东西。

分布式场景，就是线程的所有场景。多线程加分布式锁，解决共享资源安全性问题。

微服务之后，还会遇到缓存的一致性问题。使用缓存的目的是为了减轻服务端的压力，缓存之后带来的优点是热点数据非常快。但是会遇到缓存一致性的问题。

微服务的最终就是云原生，其实跟开发单体应用没什么区别。

模块和系统之间是否需要解耦，稳定性后可能会有问题。
如何去做解耦，高内聚，低耦合。技术服务于业务。职责的单一。这些都是为了解决开发效率的问题。


本质复杂度，偶然复杂度，到底是项目本身就很复杂还是什么原因要一开始就微服务。

本质复杂度绕不过去，但是偶然复杂度可以绕过去，redis如果不熟悉，可以换其他的东西。

定位要清晰，初级，中级，高级，如果是高级的话，对于系统和模块要非常清晰，高级程序员对整个系统有个全局认识，架构师对于整个系统和周边的衍生，面要广，到上面涉及的资源越多。

微服务：模仿java体系做的一套东西，最传统最可靠的实现方式，跟SOA类似，但是比SOA更抽象更简洁，AOP这块，会设计到注册中心，配置中心。

A服务和B服务中的节点，必须要自动注册到某个媒介里面，可以是数据库是文件，也可以是任何东西。
watch机制的，都可以实现配置中心和注册中心，统一管理配置，全局通知的时候要统一管理配置。

还没有上k8s，基本上做不到弹性，自动扩容收缩这些。

网关，一般分为入口网关和出口网关，一般都是入口网关。小企业对于微服务的网关，没有做防护层，ABP的DDD并不纯粹，DDD的简化，对于性能追求的不是极致，普世。

缓存：缓存引入之后会提升复杂度，网关到服务，服务和服务之间的调用。

服务熔断降级，超时或者重试的问题，多少超时时间设置多少是OK的，重试的时候跟设计的时间是矛盾的。

本地缓存和分布式缓存，本地缓存简单，但是容量受限于本机，内存不够就炸掉了，分布式缓存容量是足够的，但是运维成本增加。多个请求过来之后，是先更新缓存还是数据库。缓存如果删掉了，那么多线程的时候，线程一进来会从数据库load一遍，而线程切换不是原子性的，而另外一个线程进来的时候发现缓存已经存在，就是拿到的是旧数据。如果是先更新库，那么先进来的线程拿到的是旧的缓存，而后进来的线程拿到的是新的。

如果是先删缓存再更新库，有可能拿到的总是老的数据。

网关的话，可以不用微软的网关，或者直接用Nginx做网关，那么就需要负载均衡。

分库分表：轮询，哈希取模，把数据均匀分配在不同的机子上面。适合当前的就是最好的架构。
所有的架构90%都是水货。当前的这个单体，微服务是不是适合当前的场景。有没有必要上K8S，只有符合当前场景就是最好的。

分工明确的时候，作为小组长，分工和职责要非常明确，业务划分， 代码量小。
有很多东西要抽象出来,要提升代码的复用度，必须提供技术中台。服务和服务之间调用的时候尽量通过API调用，而不是直接操作数据库，哪怕是服务都是用的同一个数据库。

微服务需要高可用，如果微服务挂掉了，那还不如单体的可用性。
不同的服务可能还会用不同的数据库，或者不同的缓存机制，不可能都是前篇一律。DDD要对24种设计模式非常娴熟，要对DDD理论非常熟悉，还要对面向对象非常熟悉。DDD还是为了解决未知的复杂度。
DDD最重要的是领域层，.net生态圈，太依赖微软体系，离开了微软体系就蒙蔽了就不会DDD了，以为所有的微服务都需要ABP框架。

领域层是用来处理业务的，底层不需要关注上层，都是依赖于抽象，而不是具体业务。
DDD种基础设施层是最底层的，应用层都依赖于基础设施层。UI 层，应用层，都可以删掉。

开闭原则是最重要的，不要修改父类方法，有些行为不应该由父类去修改，会影响整个系统的稳定性。
不能强迫依赖于那些不必要以来的东西，接口的依赖应该是最小的依赖。

迪米特法则，就是A系统和B系统，不需要直接交互，通过中间人去处理。A可以干自己的事情，B可以也可以干自己的事情，而结合点，需要一个中间经纪人C，去产生关系。如果是A直接调用B，而B直接调用A，那么复杂度就会上升，这种中间层C就是防腐层。

基本上都是一个原理，扩展和修改关闭。聚合就是合成原则，有一定逻辑联系的实体聚集在一起就是聚合。组合，就是不同的模块组合在一起。脱离到整体之后没有任何含义，这个就是值对象和实体对象的常见的区别，合成和复用的原则，继承复用和合成复用。

做架构设计的时候，别人首先问架构设计。首先是看架构的复杂度，系统的复杂度来源哪里，到底是业务复杂还是技术复杂， 如果是技术复杂都可以绕过去，开源的不行，可以用商用的，redis不行，用mamencach，技术方案一个不行，可以用另外一个。消息队列这块可能会有分库分表的可能性，消息队列，异步持久化，MQ消息会非常大，就会涉及到分库分表，各种不稳定就来了。

限流，降级，熔断一定要掌握，需要有场景才能理解。

很多程序员最大的通病就是哪个语言好，其实没有纠结处。没有最好的架构，只要适合当前的就是最合理的架构。脱离实际，为了技术而技术。方案落地的时候，深层的原理都要自己掌握。需要提前调研，去吃透，评估能不能落地，才能避免风险。

分布式锁，跟我们多线程中的一摸一样，如果把分布式吃透之后换语言都是次要的。
文件处理的时候，对于流的理解不是很到位，数据流的处理，比如文件的读取，并发的时候异步流，阻塞流，一边剥橘子，一边放橘子，基本功不扎实的时候，一边放橘子还要一边榨汁，一边打标，就可以开3个线程同时处理。I/O流基本功，输入输出缓冲流，装饰着模式要非常理解。

不是为了策略模式而策略，不是为了工厂而工厂，也不是为了装饰器而装饰器。
一定要形成自己的知识体系。

形成自己的知识体系，大部分都是互通的，前端只要基础扎实的话，几天就可以搞定。
云原生这块的东西，docker  k8s需要掌握。docker挂载配置的时候，容器怎么持久化这些东西，服务其他团队的时候，别人只需要挂载卷的名字的时候。

RPC之间传参，多进程之间如何传递上下文，如何维护。全国有4000多个节点。200多个人开发，最后只剩下70个人。接触到复杂系统之后，有些东西，岗位被迫去接受那些东西。


越通用的东西越复杂，约定是架构的一部分，技术是架构的一部分，业务也是架构的一部分。
技术又分为很多的技术点。DDD如何跟真正的技术打交道。

EntityFramework，脱离了ABP很多东西玩不转，如果扩展到RabbitMq。
企业内部项目，做大型项目不合适，使用上都是把EntityFramework去查。

用Linq的时候，其实就是把业务层的东西交给数据库去承载。如果要使用国产数据库的时候，如果不允许使用linq，要做迁移。业务逻辑泄露了。数据库只负责存储业务逻辑。Linq Tree。
















